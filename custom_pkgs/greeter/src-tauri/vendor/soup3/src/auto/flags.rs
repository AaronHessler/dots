// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::{bitflags::bitflags, prelude::*, translate::*};
use std::fmt;

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "SoupCacheability")]
    pub struct Cacheability: u32 {
        #[doc(alias = "SOUP_CACHE_CACHEABLE")]
        const CACHEABLE = ffi::SOUP_CACHE_CACHEABLE as _;
        #[doc(alias = "SOUP_CACHE_UNCACHEABLE")]
        const UNCACHEABLE = ffi::SOUP_CACHE_UNCACHEABLE as _;
        #[doc(alias = "SOUP_CACHE_INVALIDATES")]
        const INVALIDATES = ffi::SOUP_CACHE_INVALIDATES as _;
        #[doc(alias = "SOUP_CACHE_VALIDATES")]
        const VALIDATES = ffi::SOUP_CACHE_VALIDATES as _;
    }
}

impl fmt::Display for Cacheability {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for Cacheability {
    type GlibType = ffi::SoupCacheability;

    #[inline]
    fn into_glib(self) -> ffi::SoupCacheability {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SoupCacheability> for Cacheability {
    #[inline]
    unsafe fn from_glib(value: ffi::SoupCacheability) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for Cacheability {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::soup_cacheability_get_type()) }
    }
}

impl glib::HasParamSpec for Cacheability {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for Cacheability {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Cacheability {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for Cacheability {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Cacheability> for glib::Value {
    #[inline]
    fn from(v: Cacheability) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "SoupExpectation")]
    pub struct Expectation: u32 {
        #[doc(alias = "SOUP_EXPECTATION_UNRECOGNIZED")]
        const UNRECOGNIZED = ffi::SOUP_EXPECTATION_UNRECOGNIZED as _;
        #[doc(alias = "SOUP_EXPECTATION_CONTINUE")]
        const CONTINUE = ffi::SOUP_EXPECTATION_CONTINUE as _;
    }
}

impl fmt::Display for Expectation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for Expectation {
    type GlibType = ffi::SoupExpectation;

    #[inline]
    fn into_glib(self) -> ffi::SoupExpectation {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SoupExpectation> for Expectation {
    #[inline]
    unsafe fn from_glib(value: ffi::SoupExpectation) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for Expectation {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::soup_expectation_get_type()) }
    }
}

impl glib::HasParamSpec for Expectation {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for Expectation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Expectation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for Expectation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Expectation> for glib::Value {
    #[inline]
    fn from(v: Expectation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "SoupMessageFlags")]
    pub struct MessageFlags: u32 {
        #[doc(alias = "SOUP_MESSAGE_NO_REDIRECT")]
        const NO_REDIRECT = ffi::SOUP_MESSAGE_NO_REDIRECT as _;
        #[doc(alias = "SOUP_MESSAGE_NEW_CONNECTION")]
        const NEW_CONNECTION = ffi::SOUP_MESSAGE_NEW_CONNECTION as _;
        #[doc(alias = "SOUP_MESSAGE_IDEMPOTENT")]
        const IDEMPOTENT = ffi::SOUP_MESSAGE_IDEMPOTENT as _;
        #[doc(alias = "SOUP_MESSAGE_DO_NOT_USE_AUTH_CACHE")]
        const DO_NOT_USE_AUTH_CACHE = ffi::SOUP_MESSAGE_DO_NOT_USE_AUTH_CACHE as _;
        #[doc(alias = "SOUP_MESSAGE_COLLECT_METRICS")]
        const COLLECT_METRICS = ffi::SOUP_MESSAGE_COLLECT_METRICS as _;
    }
}

impl fmt::Display for MessageFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for MessageFlags {
    type GlibType = ffi::SoupMessageFlags;

    #[inline]
    fn into_glib(self) -> ffi::SoupMessageFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SoupMessageFlags> for MessageFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::SoupMessageFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for MessageFlags {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::soup_message_flags_get_type()) }
    }
}

impl glib::HasParamSpec for MessageFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for MessageFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MessageFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for MessageFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MessageFlags> for glib::Value {
    #[inline]
    fn from(v: MessageFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "SoupServerListenOptions")]
    pub struct ServerListenOptions: u32 {
        #[doc(alias = "SOUP_SERVER_LISTEN_HTTPS")]
        const HTTPS = ffi::SOUP_SERVER_LISTEN_HTTPS as _;
        #[doc(alias = "SOUP_SERVER_LISTEN_IPV4_ONLY")]
        const IPV4_ONLY = ffi::SOUP_SERVER_LISTEN_IPV4_ONLY as _;
        #[doc(alias = "SOUP_SERVER_LISTEN_IPV6_ONLY")]
        const IPV6_ONLY = ffi::SOUP_SERVER_LISTEN_IPV6_ONLY as _;
    }
}

impl fmt::Display for ServerListenOptions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ServerListenOptions {
    type GlibType = ffi::SoupServerListenOptions;

    #[inline]
    fn into_glib(self) -> ffi::SoupServerListenOptions {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::SoupServerListenOptions> for ServerListenOptions {
    #[inline]
    unsafe fn from_glib(value: ffi::SoupServerListenOptions) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ServerListenOptions {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::soup_server_listen_options_get_type()) }
    }
}

impl glib::HasParamSpec for ServerListenOptions {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        |name| Self::ParamSpec::builder(name)
    }
}

impl glib::value::ValueType for ServerListenOptions {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ServerListenOptions {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ServerListenOptions {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ServerListenOptions> for glib::Value {
    #[inline]
    fn from(v: ServerListenOptions) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
