//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/cloudkit/ckrecordzonecapabilities?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CKRecordZoneCapabilities(pub NSUInteger);
bitflags::bitflags! {
    impl CKRecordZoneCapabilities: NSUInteger {
/// This zone supports CKFetchRecordChangesOperation
        #[doc(alias = "CKRecordZoneCapabilityFetchChanges")]
        const FetchChanges = 1<<0;
/// Batched changes to this zone happen atomically
        #[doc(alias = "CKRecordZoneCapabilityAtomic")]
        const Atomic = 1<<1;
/// Records in this zone can be shared
        #[doc(alias = "CKRecordZoneCapabilitySharing")]
        const Sharing = 1<<2;
/// This zone supports a single CKShare record that shares all records in the zone
        #[doc(alias = "CKRecordZoneCapabilityZoneWideSharing")]
        const ZoneWideSharing = 1<<3;
    }
}

unsafe impl Encode for CKRecordZoneCapabilities {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for CKRecordZoneCapabilities {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cloudkit/ckrecordzonedefaultname?language=objc)
    pub static CKRecordZoneDefaultName: &'static NSString;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/cloudkit/ckrecordzone?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKRecordZone;
);

extern_conformance!(
    unsafe impl NSCoding for CKRecordZone {}
);

extern_conformance!(
    unsafe impl NSCopying for CKRecordZone {}
);

unsafe impl CopyingHelper for CKRecordZone {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKRecordZone {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CKRecordZone {}
);

impl CKRecordZone {
    extern_methods!(
        #[unsafe(method(defaultRecordZone))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultRecordZone() -> Retained<CKRecordZone>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(initWithZoneName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithZoneName(
            this: Allocated<Self>,
            zone_name: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "CKRecordZoneID")]
        #[unsafe(method(initWithZoneID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithZoneID(
            this: Allocated<Self>,
            zone_id: &CKRecordZoneID,
        ) -> Retained<Self>;

        #[cfg(feature = "CKRecordZoneID")]
        #[unsafe(method(zoneID))]
        #[unsafe(method_family = none)]
        pub unsafe fn zoneID(&self) -> Retained<CKRecordZoneID>;

        /// Capabilities on locally-created record zones are not valid until the record zone is saved. Capabilities on record zones fetched from the server are valid.
        #[unsafe(method(capabilities))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilities(&self) -> CKRecordZoneCapabilities;

        #[cfg(feature = "CKReference")]
        /// The share property on a record zone will only be set on zones fetched from the server and only if a
        /// corresponding zone-wide share record for the zone exists on the server.
        ///
        /// You can create a zone-wide share for a zone using
        ///
        /// ```text
        ///  -[CKShare initWithRecordZoneID:]
        /// ```
        ///
        /// .
        ///
        /// Zone-wide sharing is only supported in zones with the
        /// `CKRecordZoneCapabilityZoneWideSharing`sharing capability.
        /// You cannot share a zone if it already contains shared records.
        #[unsafe(method(share))]
        #[unsafe(method_family = none)]
        pub unsafe fn share(&self) -> Option<Retained<CKReference>>;
    );
}
