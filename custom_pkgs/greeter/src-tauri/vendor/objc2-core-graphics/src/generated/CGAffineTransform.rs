//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgaffinetransformidentity?language=objc)
    pub static CGAffineTransformIdentity: CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformMake(
        a: CGFloat,
        b: CGFloat,
        c: CGFloat,
        d: CGFloat,
        tx: CGFloat,
        ty: CGFloat,
    ) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformMakeTranslation(tx: CGFloat, ty: CGFloat) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformMakeScale(sx: CGFloat, sy: CGFloat) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformMakeRotation(angle: CGFloat) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformIsIdentity(t: CGAffineTransform) -> bool;
}

extern "C-unwind" {
    pub fn CGAffineTransformTranslate(
        t: CGAffineTransform,
        tx: CGFloat,
        ty: CGFloat,
    ) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformScale(
        t: CGAffineTransform,
        sx: CGFloat,
        sy: CGFloat,
    ) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformRotate(t: CGAffineTransform, angle: CGFloat) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformInvert(t: CGAffineTransform) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformConcat(
        t1: CGAffineTransform,
        t2: CGAffineTransform,
    ) -> CGAffineTransform;
}

extern "C-unwind" {
    pub fn CGAffineTransformEqualToTransform(t1: CGAffineTransform, t2: CGAffineTransform) -> bool;
}

extern "C-unwind" {
    pub fn CGPointApplyAffineTransform(point: CGPoint, t: CGAffineTransform) -> CGPoint;
}

extern "C-unwind" {
    pub fn CGSizeApplyAffineTransform(size: CGSize, t: CGAffineTransform) -> CGSize;
}

extern "C-unwind" {
    pub fn CGRectApplyAffineTransform(rect: CGRect, t: CGAffineTransform) -> CGRect;
}

extern "C-unwind" {
    /// Decompose a CGAffineTransform into a scale * shear * rotation * translation
    ///
    /// This decomposition method may be used to provide insight into what a
    /// arbitrary CGAffineTransform does. This may be necessary, for example, because
    /// an algorithm would like to know what the scaling portion of a transform is before rotation,
    /// or perhaps because some part of a transform is undesired and your application would like
    /// to replace a portion of it with a different transformation.
    ///
    /// Since there are many ways to make a affine transform out of other affine transforms
    /// this method can not tell us the ordering of geometric steps used to create the original
    /// CGAffineTransform. It tells us what the transform does, not how it was made.
    ///
    ///
    /// Parameter `transform`: The CGAffineTransform to decompose
    ///
    /// Returns: A decomposed set of geometric operations, the product of which is the CGAffineTransform.
    pub fn CGAffineTransformDecompose(transform: CGAffineTransform) -> CGAffineTransformComponents;
}

extern "C-unwind" {
    /// Create CGAffineTransform from scale * shear * rotation * translation CGAffineTransformComponents
    ///
    /// Parameter `components`: The set of CGAffineTransformComponents to use to create a new CGAffineTransform
    ///
    /// Returns: A new CGAffineTransform built from the provided components
    pub fn CGAffineTransformMakeWithComponents(
        components: CGAffineTransformComponents,
    ) -> CGAffineTransform;
}

// TODO: pub fn __CGAffineTransformMake(a: CGFloat,b: CGFloat,c: CGFloat,d: CGFloat,tx: CGFloat,ty: CGFloat,) -> CGAffineTransform;

// TODO: pub fn __CGPointApplyAffineTransform(point: CGPoint,t: CGAffineTransform,) -> CGPoint;

// TODO: pub fn __CGSizeApplyAffineTransform(size: CGSize,t: CGAffineTransform,) -> CGSize;
